<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/aqvq/aqvq</id><title>RSS feed of aqvq's aqvq</title><updated>2024-12-04T05:57:19.165565+00:00</updated><link href="https://github.com/aqvq/aqvq"/><link href="https://raw.githubusercontent.com/aqvq/aqvq/main/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/aqvq/aqvq/issues/9</id><title>EQA项目问题检索</title><updated>2024-12-04T05:57:19.534321+00:00</updated><content type="html"><![CDATA[<p>此issue用于记录在EQA项目遇到的各种问题及解决方案。</p>
]]></content><link href="https://github.com/aqvq/aqvq/issues/9"/><published>2024-12-02T11:43:23+00:00</published></entry><entry><id>https://github.com/aqvq/aqvq/issues/8</id><title>服务器维护经历 - 网络连接不上</title><updated>2024-12-04T05:57:19.659422+00:00</updated><content type="html"><![CDATA[<p><code>ping baidu.com</code>出现<a href="https://www.cnblogs.com/hanframe/p/17095506.html">Temporary failure in name resolution</a>，以为是dns的问题，修改文件<code>/etc/resolv.conf</code>，发现运行<code>sudo systemctl restart systemd-resolved.service</code>发现又变回了原来的样子，修改无效。</p>
<p>后来发现是网卡被禁用了，通过<code>ifconfig</code>命令启用恢复正常。参考这篇文章：<a href="https://www.cnblogs.com/zh-dream/p/13405799.html">Ubuntu 18.04网络不通，netplan命令不存在</a></p>
]]></content><link href="https://github.com/aqvq/aqvq/issues/8"/><category term="Linux"/><category term="服务器"/><published>2024-11-29T13:02:23+00:00</published></entry><entry><id>https://github.com/aqvq/aqvq/issues/7</id><title>常用Linux操作</title><updated>2024-12-04T05:57:19.797627+00:00</updated><content type="html"><![CDATA[<h1>定时任务</h1>
<pre><code class="language-Bash"># 编辑
crontab -u user -e
# * * * * * command_to_execute
# - - - - -
# | | | | |
# | | | | +---- 星期几 (0 - 7) (周日是0和7)
# | | | +------ 月 (1 - 12)
# | | +-------- 日期 (1 - 31)
# | +---------- 小时 (0 - 23)
# +------------ 分钟 (0 - 59)
# 样例（每分钟执行一次）：* * * * * /path/to/test_script.sh
5 0 * * * /usr/bin/python3 /home/user/toInternet.py # 每天00:05执行一次
crontab -u user -l
# 查看日志
grep CRON /var/log/syslog
</code></pre>
<h1>不同机器传输文件</h1>
<pre><code class="language-TypeScript"># scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file] [-l limit] [-o ssh_option] [-P port] [-S program] [[user@]host1:]file1 ... [[user@]host2:]file2
# 示例
scp -r -P 10004 user@xxx.tpddns.cn:/data1/home/user/data ~/data
scp -r -P 10003 Matterport3DSimulator user@xxx.tpddns.cn:/data1/home/user/Matterport3DSimulator
# 命令解析：
# 下载 scp -P ssh端口 用户名@IP地址:文件路径 本地保存路径
# 上传 scp -P ssh端口 文件路径 用户名@IP地址:目的地址
# 文件夹使用-r
</code></pre>
<h3>支持断点续传</h3>
<pre><code class="language-Bash"># 参数说明：
# -a 可以递归同步，并同步元信息
# rsync -a source destination 将source同步到destination/source中
# rsync -a source/ destination 将source同步到destination中
# -n 模拟命令执行的结果，并不真的执行命令，可以用来看哪些内容会被同步
# rsync -av --delete source/ destination 镜像同步，source删除文件，destination同步删除
# rsync -av --exclude=&#x27;*.txt&#x27; source/ destination 排除文件
# rsync -av --exclude &#x27;file1.txt&#x27; --exclude &#x27;dir1/*&#x27; source/ destination 排除多个文件
# 参考链接：https://www.ruanyifeng.com/blog/2020/08/rsync.html
rsync -avP -e &quot;ssh -p 10002&quot; /data1/home/user/code/pglite/data/train/upper user@www.tpddns.cn:/data2/home/user/code/data
</code></pre>
<h1>后台运行程序</h1>
<h2>方法一</h2>
<ol>
<li>
<p>新建会话<code>tmux new -s &lt;session-name&gt;</code></p>
</li>
<li>
<p>在 Tmux 窗口运行所需的程序。</p>
</li>
<li>
<p>按下快捷键<code>Ctrl+b d</code>将会话分离。</p>
</li>
<li>
<p>下次使用时，重新连接到会话<code>tmux attach -t &lt;session-name&gt;</code></p>
</li>
</ol>
<h2>方法二</h2>
<p>带日志：</p>
<pre><code class="language-Bash">nohup python my.py &gt;&gt; ~/my.log 2&gt;&amp;1 &amp;
</code></pre>
<p>不带日志：</p>
<pre><code class="language-Bash">nohup python my.py &gt; /dev/null 2&gt;&amp;1 &amp;
</code></pre>
<h1>Linux命令行设置代理</h1>
<p>Clash下载地址: <a href="https://github.com/Kuingsmile/clash-core/releases">https://github.com/Kuingsmile/clash-core/releases</a></p>
<p>建议下载版本<code>clash-linux-amd64-v``3</code>，解压到集群个人目录中，添加可执行权限。</p>
<pre><code class="language-Bash">chmod +x clash
</code></pre>
<p>按下图所示，从PC端<code>C:\Users\xxx\.config\clash</code>复制配置文件到集群<code>~/.config/clash/</code>上:</p>
<p><img src="https://kjyq8je1lf.feishu.cn/space/api/box/stream/download/asynccode/?code=N2IwYjk3OTg4MTRjMDUxMzY3ZTExNGEwNzU1NzQwNTJfU0hsMGN6cjNQbDZLZ3BydkNMMUk3Qms1YlVHeG1DdmZfVG9rZW46SEdmTWJTcE13b29FcTl4NVhwOGNiQzNRbm1jXzE3MzI4Njc0OTM6MTczMjg3MTA5M19WNA" alt="" /></p>
<p>将<code>profiles</code>文件夹中的<code>yml配置文件</code>复制到linux<code>~/.config/clash/</code>中并改名为<code>config.yml</code>。linux配置文件夹中共有三个文件</p>
<p><img src="https://kjyq8je1lf.feishu.cn/space/api/box/stream/download/asynccode/?code=MTYxMGI3YTZkZTc4ZjJkYWJlZmRiMjVhM2QxYTcwOWZfaWVzYVBIZ044elBuTHNnRGo1YkVWcWJ3TlM5Z1JGbFlfVG9rZW46WWpnVWI3Nzd1b3c0b0p4RGlKWmNmVzhSbkxiXzE3MzI4Njc0OTM6MTczMjg3MTA5M19WNA" alt="" /></p>
<p>打开<code>config.yml</code>文件，修改为未占用的端口号:</p>
<p><img src="https://kjyq8je1lf.feishu.cn/space/api/box/stream/download/asynccode/?code=NmI5YTUxNTk0NjUxZjY2ZDVjZWNiZDQ0ZGU5MjAzZTNfN0M1MEpJTG9QVWo5Vm11RlMwOHFUcGFPSWEwT1hGRUpfVG9rZW46WHR1Z2IzOXVab29XdXB4cUhlT2NGU1gzbjljXzE3MzI4Njc0OTM6MTczMjg3MTA5M19WNA" alt="" /></p>
<p>一个简单的快速操作clash启动、停止、重启、查询状态的shell脚本：</p>
<pre><code class="language-Bash">#!/bin/bash

LOG_FILE=&quot;$HOME/clash_service.log&quot;  # 日志文件路径
DEFAULT_PORT=7890  # 默认端口

log_message() {
    echo &quot;$(date +&quot;%Y-%m-%d %H:%M:%S&quot;) - $1&quot; &gt;&gt; &quot;$LOG_FILE&quot;
}

# 检查指定端口是否被占用
check_port() {
    pInfo=$(lsof -i :$1 | grep -v &quot;PID&quot; | awk &#x27;{print $2, $1}&#x27; | uniq)
    pid=$(echo $pInfo | awk &#x27;{print $1}&#x27;)  # 获取 PID
    pname=$(echo $pInfo | awk &#x27;{print $2}&#x27;)  # 获取进程名称
}

# 启动 Clash 服务，允许指定端口
start_clash() {
    port=$1
    if [ -z &quot;$port&quot; ]; then
        port=$DEFAULT_PORT  # 如果未指定端口，则使用默认端口
    fi

    check_port $port
    if [ &quot;$pname&quot; = &quot;clash&quot; ]; then
        echo &quot;Clash 服务已经在运行 (端口: $port, PID: $pid)。&quot;
        log_message &quot;Attempted to start Clash on port $port, but it is already running (PID: $pid).&quot;
    else
        nohup clash -f ~/.config/clash/config.yml &gt; /dev/null 2&gt;&amp;1 &amp;  # 指定端口启动 Clash，并将输出重定向
        sleep 2  # 等待服务启动
        check_port $port
        if [ &quot;$pname&quot; = &quot;clash&quot; ]; then
            echo &quot;Clash 服务启动成功 (端口: $port, PID: $pid)。&quot;
            log_message &quot;Clash service started successfully on port $port (PID: $pid).&quot;
        else
            echo &quot;Clash 服务启动失败，请检查配置或日志。&quot;
            log_message &quot;Failed to start Clash service on port $port.&quot;
        fi
    fi
}

# 停止 Clash 服务
stop_clash() {
    port=$1
    if [ -z &quot;$port&quot; ]; then
        port=$DEFAULT_PORT  # 如果未指定端口，则使用默认端口
    fi

    check_port $port
    if [ &quot;$pname&quot; = &quot;clash&quot; ]; then
        echo &quot;正在停止 Clash 服务 (端口: $port, PID: $pid)...&quot;
        kill -9 &quot;$pid&quot;
        echo &quot;Clash 服务已停止。&quot;
        log_message &quot;Clash service stopped (PID: $pid).&quot;
    else
        echo &quot;Clash 服务未运行在端口 $port。&quot;
        log_message &quot;Attempted to stop Clash on port $port, but it was not running.&quot;
    fi
}

# 重启 Clash 服务
restart_clash() {
    port=$1
    echo &quot;正在重启 Clash 服务 (端口: $port)...&quot;
    stop_clash $port
    start_clash $port
}

# 打开代理环境变量
proxy_on() {
    port=$1
    if [ -z &quot;$port&quot; ]; then
        port=$DEFAULT_PORT  # 如果未指定端口，则使用默认端口
    fi
    export http_proxy=&quot;http://127.0.0.1:$port&quot;
    export https_proxy=&quot;http://127.0.0.1:$port&quot;
    # export all_proxy=&quot;http://127.0.0.1:$port&quot;
    echo &quot;代理已开启，端口: $port&quot;
    log_message &quot;Proxy environment variables enabled on port $port.&quot;
}

# 关闭代理环境变量
proxy_off() {
    unset http_proxy
    unset https_proxy
    unset all_proxy
    echo &quot;代理已关闭。&quot;
    log_message &quot;Proxy environment variables disabled.&quot;
}

# 主程序逻辑
case &quot;$1&quot; in
    start)
        start_clash $2  # 第二个参数为端口号
        ;;
    stop)
        stop_clash $2  # 第二个参数为端口号
        ;;
    restart)
        restart_clash $2  # 第二个参数为端口号
        ;;
    status)
        port=$2
        if [ -z &quot;$port&quot; ]; then
            port=$DEFAULT_PORT  # 使用默认端口
        fi
        check_port $port
        if echo &quot;$pname&quot; | grep -qi &quot;clash&quot;; then
            echo &quot;Clash 正在运行 (端口: $port, PID: $pid)。&quot;
        else
            echo &quot;Clash 未运行在端口 $port。&quot;
        fi
        ;;
    on)
        port=$2
        if [ -z &quot;$port&quot; ]; then
            port=$DEFAULT_PORT
        fi
        start_clash $port  # 启动 Clash 服务
        proxy_on $port # 启用代理
        ;;
    off)
        port=$2
        if [ -z &quot;$port&quot; ]; then
            port=$DEFAULT_PORT
        fi
        stop_clash $port  # 停止 Clash 服务
        proxy_off $port # 关闭代理
        ;;
    *)
        echo &quot;使用方法: $0 {start|stop|restart|status|on|off} [端口号]&quot;
        ;;
esac
</code></pre>
<p>使用方法（如果启动失败可能是端口号的问题）：</p>
<pre><code class="language-Bash"># 开启代理
. ~/clash.sh on
# 关闭代理
. ~/clash.sh off
# 重启
. ~/clash.sh restart
# 查询状态
. ~/clash.sh status
# 仅启动clash服务
. ~/clash.sh start
# 仅停止clash服务
. ~/clash.sh stop
</code></pre>
<blockquote>
<p>.是source命令的缩写，on/off如果使用bash命令不会生效，必须使用source。</p>
<p>命令后可跟端口号参数，但必须与配置文件的端口号一致。</p>
</blockquote>
]]></content><link href="https://github.com/aqvq/aqvq/issues/7"/><category term="Linux"/><category term="服务器"/><published>2024-11-29T08:06:34+00:00</published></entry><entry><id>https://github.com/aqvq/aqvq/issues/6</id><title>电脑直连网络摄像头</title><updated>2024-12-04T05:57:19.922720+00:00</updated><content type="html"><![CDATA[<p>型号：DH-IPC-HFW54ZYZF1Y-ABC
下载工具：<a href="https://support.dahuatech.com/tools/software">全部-浙江大华技术股份有限公司 (dahuatech.com)</a>
IP地址：192.168.1.108
掩码：255.255.255.0</p>
<blockquote>
<p>网线连接电脑，可用网口转USB转接线</p>
</blockquote>
<p>在电脑设置中找到该网络，设置IP在同一网段，比如192.168.1.55</p>
<blockquote>
<p>此设置不影响网络正常联网，不要设置错了网络</p>
</blockquote>
<p>设置完之后即可进入网页进行设置。</p>
<p><a href="https://blog.csdn.net/xiejiashu/article/details/38523437">海康、大华IpCamera RTSP地址和格式-CSDN博客</a></p>
]]></content><link href="https://github.com/aqvq/aqvq/issues/6"/><category term="计算机视觉"/><published>2024-11-29T07:51:02+00:00</published></entry><entry><id>https://github.com/aqvq/aqvq/issues/4</id><title>CUB转YOLO格式数据集</title><updated>2024-12-04T05:57:20.042514+00:00</updated><content type="html"><![CDATA[<p>参考文章：
<a href="https://www.bilibili.com/read/cv21940047/#:~:text=%E6%89%80%E4%BB%A5CUB%E6%95%B0%E6%8D%AE%E9%9B%86,%EF%BC%8C%E8%AF%B7%E5%9C%A8__get">CUB_200_2011数据集转Yolo格式 - 哔哩哔哩 (bilibili.com)</a></p>
<p>CUB数据集下载：
<a href="https://data.caltech.edu/records/65de6-vp158/files/CUB_200_2011.tgz">https://data.caltech.edu/records/65de6-vp158/files/CUB_200_2011.tgz</a></p>
<p>在此基础上添加细粒度类别，自动生成数据集yaml配置文件，具体源码如下：</p>
<pre><code class="language-python">import os  
import cv2  
  
  
class Manager:  
    def __init__(self, path, target, train=True):  
        self.class_names = None  
        self.root = path  
        self.target = target  
        self.is_train = train  
        self.images_path = {}  
        self.phase_name = &#x27;train&#x27; if train else &#x27;val&#x27;  
        with open(os.path.join(self.root, &#x27;images.txt&#x27;)) as f:  
            for line in f:  
                image_id, path = line.split()  
                self.images_path[image_id] = path  
  
        # 获取类别标签dict  
        self.class_ids = {}  
        with open(os.path.join(self.root, &#x27;image_class_labels.txt&#x27;)) as f:  
            for line in f:  
                image_id, class_id = line.split()  
                self.class_ids[image_id] = class_id  
  
        # 获取标注框  
        self.bondingbox = {}  
        with open(os.path.join(self.root, &#x27;bounding_boxes.txt&#x27;)) as f:  
            for line in f:  
                image_id, x, y, w, h = line.split()  
                x, y, w, h = float(x), float(y), float(w), float(h)  
                self.bondingbox[image_id] = (x, y, w, h)  
  
        # 获取train/test数据id列表  
        self.data_id = []  
        if self.is_train:  
            with open(os.path.join(self.root, &#x27;train_test_split.txt&#x27;)) as f:  
                for line in f:  
                    image_id, is_train = line.split()  
                    if int(is_train):  
                        self.data_id.append(image_id)  
        if not self.is_train:  
            with open(os.path.join(self.root, &#x27;train_test_split.txt&#x27;)) as f:  
                for line in f:  
                    image_id, is_train = line.split()  
                    if not int(is_train):  
                        self.data_id.append(image_id)  
  
    def transfer(self):  
        # 清空 train.txt / val.txt        path_file_clear = open(os.path.join(self.target, (self.phase_name + &#x27;.txt&#x27;)), &#x27;w&#x27;)  
        path_file_clear.close()  
        for i in range(self.__len__()):  
            image, file_name, x, y, w, h, label = self.__getitem__(i)  
            file_path = os.path.join(self.target, &#x27;images&#x27;, self.phase_name, file_name)  
            cv2.imwrite(file_path, image)  
            print(f&quot;Write image {file_path}&quot;)  
            label_file = open(os.path.join(self.target, &#x27;labels&#x27;, self.phase_name, (os.path.splitext(file_name)[0] +  
                                                                                    &#x27;.txt&#x27;)), &#x27;w&#x27;)  
            label_file.write(&#x27;{} {} {} {} {}&#x27;.format(label, x, y, w, h))  
            label_file.close()  
            path_file = open(os.path.join(self.target, (self.phase_name + &#x27;.txt&#x27;)), &#x27;a&#x27;)  
            path_file.write(&#x27;{}{}&#x27;.format((&#x27;\n&#x27; if i != 0 else &#x27;&#x27;), file_path))  
            path_file.close()  
  
    def write_yaml(self):  
        self.class_names = {}  
        with open(os.path.join(self.root, &#x27;classes.txt&#x27;)) as f:  
            for line in f:  
                class_id, class_name = line.split()  
                class_name = class_name.split(&#x27;.&#x27;)[-1]  
                self.class_names[class_id] = class_name  
  
        with open(os.path.join(self.target, &#x27;data.yaml&#x27;), &#x27;w&#x27;) as f:  
            f.write(&#x27;path: {}\n&#x27;.format(self.target))  
            f.write(&#x27;train: images/train\n&#x27;)  
            f.write(&#x27;val: images/val\n&#x27;)  
            f.write(&#x27;test: \n&#x27;)  
            f.write(&#x27;names:\n&#x27;)  
            for k, v in self.class_names.items():  
                f.write(&#x27;  {}: {}\n&#x27;.format(int(k) - 1, v))  
        print(&quot;Write yaml file successfully!&quot;)  
  
    def __len__(self):  
        return len(self.data_id)  
  
    def __getitem__(self, index):  
        image_id = self.data_id[index]  
        label = int(self._get_class_by_id(image_id)) - 1  
        path = self._get_path_by_id(image_id)  
        file_name = os.path.basename(path)  
        image = cv2.imread(os.path.join(self.root, &#x27;images&#x27;, path))  
        width = image.shape[1]  
        height = image.shape[0]  
        x, y, w, h = self.bondingbox[image_id]  
        x = (x + (w / 2)) / width  
        w /= width  
        y = (y + (h / 2)) / height  
        h /= height  
  
        return image, file_name, x, y, w, h, label  
  
    def _get_path_by_id(self, image_id):  
  
        return self.images_path[image_id]  
  
    def _get_class_by_id(self, image_id):  
  
        return self.class_ids[image_id]  
  
    def _get_bbox_by_id(self, image_id):  
  
        return self.bondingbox[image_id]  
  
  
def mkdirs(path):  
    if not os.path.exists(path):  
        os.makedirs(path)  
    for phase in [&#x27;train&#x27;, &#x27;val&#x27;]:  
        images_path = os.path.join(path, &#x27;images&#x27;, phase)  
        labels_path = os.path.join(path, &#x27;labels&#x27;, phase)  
        if not os.path.exists(images_path):  
            os.makedirs(images_path)  
        if not os.path.exists(labels_path):  
            os.makedirs(labels_path)  
  
  
if __name__ == &quot;__main__&quot;:  
    # 原数据集根目录  
    root = r&#x27;E:\Datasets\CUB_200_2011\CUB_200_2011&#x27;  
    # 目标yolo格式数据集根目录 - 须是完整绝对路径  
    des = r&#x27;E:\Datasets\CUB_YOLO&#x27;  
    # 创建目标路径下的文件夹  
    mkdirs(des)  
    manager_train = Manager(root, des, train=True)  
    manager_train.transfer()  
    manager_val = Manager(root, des, train=False)  
    manager_val.transfer()  
    manager_val.write_yaml()  
    print(&#x27;Finished!&#x27;)
</code></pre>
<p>数据集说明参考文章： #3 </p>
]]></content><link href="https://github.com/aqvq/aqvq/issues/4"/><category term="YOLO"/><category term="计算机视觉"/><category term="目标检测"/><published>2024-11-28T12:16:39+00:00</published></entry></feed>